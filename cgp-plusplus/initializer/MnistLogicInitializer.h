#ifndef INITIALIZER_MNISTLOGICINITIALIZER_H_
#define INITIALIZER_MNISTLOGICINITIALIZER_H_

#include "BlackBoxInitializer.h"
#include "../problems/MnistLogicProblem.h" // Creeremo questo file al prossimo passo
#include "../functions/BooleanFunctions.h"

#include <fstream>
#include <sstream>
#include <stdexcept>
#include <iostream>

template<class E, class G, class F>
class MnistLogicInitializer : public BlackBoxInitializer<E, G, F> {
public:
    // Parameter for number of bits per class (e.g., 50)
    // Total output = 10 classes * 50 bits = 500
    const int BITS_PER_CLASS = 50; 

    MnistLogicInitializer(const std::string &p_benchmark_file)
        : BlackBoxInitializer<E, G, F>(p_benchmark_file) {
    }

    ~MnistLogicInitializer() = default;

    /**
     * @brief Reads the mnist_boolean.txt file generated by Python.
     * File format:
     * Header: NUM_SAMPLES NUM_INPUTS NUM_CLASSES
     * Rows: LABEL pixel1 pixel2 ... pixel784
     */
    void read_data() override {
        std::ifstream ifs(this->benchmark_file);
        
        if (!ifs.is_open()) {
            throw std::runtime_error("Could not open MNIST data file: " + this->benchmark_file);
        }

        int num_samples_file, num_inputs_file, num_classes_file;
        
        // 1. Read the header -> check what it does
        if (!(ifs >> num_samples_file >> num_inputs_file >> num_classes_file)) {
            throw std::runtime_error("Error reading MNIST header!");
        }

        std::cout << "Loading MNIST Data..." << std::endl;
        std::cout << "Samples: " << num_samples_file 
                  << ", Inputs: " << num_inputs_file 
                  << ", Classes: " << num_classes_file << std::endl;

        // 2. for now i set a single batch with all samples
        this->num_instances = num_samples_file;
        this->parameters->set_num_variables(num_inputs_file); // 784
        
        // Total outputs = Classes * Bits per class (e.g. 10 * 50 = 500)
        int total_outputs = num_classes_file * BITS_PER_CLASS;
        this->parameters->set_num_outputs(total_outputs);

        // 3. Allocates memory for inputs and outputs
        this->inputs = std::make_shared<std::vector<std::vector<E>>>(this->num_instances);
        this->outputs = std::make_shared<std::vector<std::vector<E>>>(this->num_instances);

        // 4. Read the rows (Label + Pixel)
        int label;
        E pixel_val;

        for (int i = 0; i < this->num_instances; ++i) {
            // A. Read the Label (first column)
            if (!(ifs >> label)) {
                throw std::runtime_error("Error reading label at line " + std::to_string(i + 1));
            }

            // Save the label as the FIRST element of the output vector.
            // The MnistLogicProblem will know that outputs[i][0] is the target class.
            // Resize to 1 just to hold the label (saves memory compared to 500)
            (*this->outputs)[i].push_back(static_cast<E>(label));

            // B. Read the Pixels (subsequent columns)
            (*this->inputs)[i].resize(num_inputs_file);
            for (int j = 0; j < num_inputs_file; ++j) {
                ifs >> pixel_val;
                (*this->inputs)[i][j] = pixel_val;
            }
        }

        std::cout << "MNIST Data Loaded Successfully." << std::endl;
        ifs.close();
    }

    /**
     * @brief Initialize boolean functions.
     */
    void init_functions() override {
        this->functions = std::make_shared<FunctionsBoolean<E>>(this->parameters);
    }

    /**
     * @brief Initialize the MNIST Logic problem.
     */
    void init_problem() override {
        this->problem = std::make_shared<MnistLogicProblem<E, G, F>>(
            this->parameters, 
            this->evaluator, 
            this->inputs,
            this->outputs, 
            this->constants, 
            this->num_instances
        );
        
        // Passiamo il parametro BITS_PER_CLASS al problema (opzionale, se lo rendiamo configurabile)
        // Per ora lo hardcodiamo o lo passiamo tramite un setter se necessario.

        // we want to minimize the number of errors (maximize correct classifications)
        this->parameters->set_minimizing_fitness(true);

        if (this->parameters->get_ideal_fitness() == -1) {
             this->parameters->set_ideal_fitness(0.01);
        }

        // REGISTRATION IN THE COMPOSITE (check what it does)
        this->composite->set_problem(this->problem);
    }
};

#endif /* INITIALIZER_MNISTLOGICINITIALIZER_H_ */